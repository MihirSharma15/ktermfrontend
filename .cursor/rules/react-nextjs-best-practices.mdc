---
alwaysApply: true
description: React and Next.js best practices and coding standards
---

# React and Next.js Best Practices

## TypeScript Standards
- Always use TypeScript with proper type hints for all functions, components, and variables
- Define interfaces for component props and API responses
- Use strict TypeScript configuration with no implicit any
- Prefer `interface` over `type` for object shapes
- Use generic types when appropriate for reusable components

## Props Management and Type Organization
- **Component Props**: Always define props interfaces with descriptive names (e.g., `ButtonProps`, `UserCardProps`)
- **Props Interface Location**: Define props interfaces in the same file as the component, or in a separate `types.ts` file for shared interfaces
- **Props Destructuring**: Always destructure props in the function signature for better readability
- **Optional Props**: Use `?` for optional props and provide sensible defaults when possible
- **Props Validation**: Use TypeScript's strict typing instead of runtime prop validation when possible
- **Children Props**: Use `React.ReactNode` for children props, `React.ReactElement` for specific element types
- **Event Handlers**: Type event handlers properly (e.g., `onClick: (event: React.MouseEvent<HTMLButtonElement>) => void`)

## Avoiding Bloated TypeScript Files
- **File Size Limit**: Keep individual TypeScript files under 300 lines when possible
- **Interface Separation**: Extract complex interfaces into separate `types.ts` or `interfaces.ts` files
- **Utility Types**: Use TypeScript utility types (`Partial`, `Pick`, `Omit`, `Record`) to avoid duplicating interfaces
- **Generic Components**: Create generic components for reusable patterns instead of duplicating similar components
- **Type Imports**: Use type-only imports (`import type { ... }`) to reduce bundle size
- **Barrel Exports**: Use `index.ts` files to re-export types and reduce import complexity
- **Component Splitting**: Break large components into smaller, focused components with their own types
- **Shared Types**: Create a `src/types/` directory for application-wide type definitions
- **API Types**: Separate API response types into `src/types/api.ts` or similar
- **Component-Specific Types**: Keep component-specific types close to the component, shared types in dedicated files

## React Component Guidelines
- Use functional components with hooks instead of class components
- Always define proper TypeScript interfaces for component props
- Use descriptive component names in PascalCase
- Keep components small and focused on a single responsibility
- Extract reusable logic into custom hooks
- Use React.memo() for performance optimization when appropriate

## Next.js App Router Best Practices
- Use the App Router structure with `src/app/` directory
- Create proper route segments with descriptive folder names
- Use `layout.tsx` for shared UI and `page.tsx` for route-specific content
- Implement proper loading states with `loading.tsx`
- Use `error.tsx` for error boundaries
- Leverage Server Components by default, use Client Components only when necessary

## File Organization
- Follow the Next.js App Router file conventions:
  - `page.tsx` - Route pages
  - `layout.tsx` - Shared layouts
  - `loading.tsx` - Loading UI
  - `error.tsx` - Error UI
  - `not-found.tsx` - 404 pages
- Organize components in logical folders within `src/components/`
- Use barrel exports (`index.ts`) for clean imports
- Keep utility functions in `src/lib/` or `src/utils/`

## State Management
- Use React's built-in state management (useState, useReducer) for local state
- Implement Context API for global state when needed
- Consider external state management libraries (Zustand, Redux Toolkit) for complex state
- Avoid prop drilling by using proper state lifting or context

## Performance Optimization
- Use dynamic imports with `next/dynamic` for code splitting
- Implement proper image optimization with `next/image`
- Use `next/font` for font optimization
- Implement proper caching strategies
- Use React.memo, useMemo, and useCallback judiciously
- Optimize bundle size with proper tree shaking

## Styling Guidelines
- Use Tailwind CSS for styling (already configured in this project)
- Follow mobile-first responsive design principles
- Use CSS modules or styled-components for component-specific styles when needed
- Implement proper dark mode support
- Use semantic HTML elements for accessibility

## API and Data Fetching
- Use Server Components for data fetching when possible
- Implement proper error handling and loading states
- Use TypeScript interfaces for API response types
- Implement proper caching with Next.js caching strategies
- Use SWR or React Query for client-side data fetching when needed

## Error Handling
- Implement proper error boundaries
- Use try-catch blocks for async operations
- Provide meaningful error messages to users
- Log errors appropriately for debugging
- Handle network errors gracefully

## Accessibility (a11y)
- Use semantic HTML elements
- Implement proper ARIA attributes
- Ensure keyboard navigation works
- Provide alt text for images
- Use proper heading hierarchy
- Test with screen readers

## Security Best Practices
- Sanitize user inputs
- Use proper authentication and authorization
- Implement CSRF protection
- Use environment variables for sensitive data
- Validate data on both client and server side
- Use HTTPS in production

## Testing Standards
- Write unit tests for utility functions
- Test React components with React Testing Library
- Implement integration tests for critical user flows
- Use proper mocking for external dependencies
- Aim for good test coverage on critical paths

## Code Quality
- Use ESLint and Prettier for code formatting
- Follow consistent naming conventions
- Write self-documenting code with clear variable names
- Add comments for complex business logic
- Use proper Git commit messages
- Implement proper code review processes

## Performance Monitoring
- Use Next.js built-in analytics
- Implement proper error tracking
- Monitor Core Web Vitals
- Use performance profiling tools
- Optimize for mobile performance

## Deployment and DevOps
- Use proper environment configurations
- Implement CI/CD pipelines
- Use proper build optimization
- Monitor application performance in production
- Implement proper logging and monitoring